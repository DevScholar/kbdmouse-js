<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virtual Keyboard</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
            color: #333;
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .description {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 40px;
            font-size: 1.1em;
            line-height: 1.6;
        }

        /* Input area styles */
        .input-section {
            max-width: 800px;
            margin: 0 auto 30px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            box-sizing: border-box; /* Ensure padding doesn't cause overflow */
        }

        /* Virtual keyboard container styles */
        .keyboard-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 30px auto;
            padding: 0 20px;
            box-sizing: border-box;
            width: 100%;
            max-width: 100%;
            min-height: 400px; /* Ensure enough space for keyboard */
        }

        prefab-virtual-keyboard {
            display: block;
            margin: 0 auto;
            width: 100%;
            max-width: 100%;
            text-align: center; /* Ensure inline content is centered */
        }

        /* Ensure keyboard content is always centered */
        prefab-virtual-keyboard::part(keyboard-container) {
            margin: 0 auto !important;
            display: inline-block !important;
        }

        /* Additional centering for natural size mode */
        prefab-virtual-keyboard[style*="px"] {
            margin: 0 auto !important;
            display: block !important;
        }

        /* Mobile portrait mode - force full width with maximum overrides */
        @media (max-width: 768px) and (orientation: portrait) {
            .keyboard-container {
                width: 100vw !important;
                max-width: 100vw !important;
                margin: 0 !important;
                padding: 0 !important;
                left: 0 !important;
                right: 0 !important;
                position: relative !important;
            }
            
            prefab-virtual-keyboard {
                width: 100vw !important;
                max-width: 100vw !important;
                margin: 0 !important;
                padding: 0 !important;
                left: 0 !important;
                right: 0 !important;
                position: relative !important;
            }
            
            /* ARCHITECTURAL PRINCIPLE: virtual-keyboard maintains natural size, never force dimensions */
            prefab-virtual-keyboard virtual-keyboard {
                /* DO NOT set width/height/margin/padding on internal virtual-keyboard */
                /* Let it maintain its natural 1044x360 size */
                width: auto !important;
                max-width: none !important;
                margin: 0 !important;
                padding: 0 !important;
                left: 0 !important;
                right: 0 !important;
            }
            
            /* Removed zoom/transform override to allow mobile scaling */
            
            /* Shadow DOM parts override - only affect prefab, not internal */
            prefab-virtual-keyboard::part(keyboard) {
                width: 100vw !important;
                max-width: 100vw !important;
                margin: 0 !important;
                padding: 0 !important;
            }
            
            /* Aggressive reset for any potential left margin sources */
            * {
                margin-left: 0 !important;
                padding-left: 0 !important;
                left: 0 !important;
            }
        }

        .input-section label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #2c3e50;
        }

        #text-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 16px;
            font-family: inherit;
            resize: vertical;
            transition: border-color 0.3s;
            box-sizing: border-box; /* Ensure padding doesn't cause width overflow */
        }

        #text-input:focus {
            outline: none;
            border-color: #3498db;
        }

        /* Active input field styles */
        .input-active {
            border-color: #27ae60 !important;
            box-shadow: 0 0 0 3px rgba(39, 174, 96, 0.1);
        }

        /* Log area styles */
        .log-section {
            max-width: 800px;
            margin: 30px auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .log-header {
            background: #34495e;
            color: white;
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .log-header h3 {
            margin: 0;
            font-size: 1.2em;
            font-weight: 500;
        }

        #clear-log {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.3s;
        }

        #clear-log:hover {
            background: #c0392b;
        }

        .event-log {
            max-height: 400px;
            overflow-y: auto;
            background: #1e1e1e;
            color: #d4d4d4;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
            padding: 15px;
            white-space: pre-wrap;
            word-break: break-all;
        }

        /* Plain text log styles - simplified */

        /* Scrollbar styles */
        .event-log::-webkit-scrollbar {
            width: 8px;
        }

        .event-log::-webkit-scrollbar-track {
            background: #34495e;
        }

        .event-log::-webkit-scrollbar-thumb {
            background: #7f8c8d;
            border-radius: 4px;
        }

        .event-log::-webkit-scrollbar-thumb:hover {
            background: #95a5a6;
        }
     
    </style>
    <style>
        /* Desktop responsive styles for small windows */
        @media screen and (max-width: 1200px) {
            .keyboard-container {
                padding: 0 15px;
                width: 100%;
                max-width: 100%;
            }
            
            prefab-virtual-keyboard {
                display: block;
                width: 100% !important; /* Use 100% width to fill container */
                max-width: 100% !important;
                margin: 0 auto;
            }
        }
        
        /* Mobile responsive styles for virtual keyboard */
        @media screen and (max-width: 768px) {
            /* Container adjustments */
            .demo-container {
                padding: 10px;
            }
            
            .keyboard-container {
                padding: 0 5px; /* Reduce padding for more space */
                margin: 20px auto;
                width: 100%;
                max-width: 100vw;
            }
            
            /* Input section adjustments */
            .input-section {
                margin: 0 auto 20px;
                padding: 15px;
            }
            
            /* Keyboard container responsive scaling */
            prefab-virtual-keyboard {
                display: block;
                width: 100% !important;
                max-width: 100vw !important;
                margin: 0 auto;
            }
            
            /* ARCHITECTURAL PRINCIPLE: For mobile, we need the keyboard to fill width
               The internal virtual-keyboard should scale with the container */
            prefab-virtual-keyboard virtual-keyboard {
                width: 100% !important;
                max-width: 100vw !important;
                /* Allow scaling while maintaining aspect ratio */
                transform-origin: top left !important;
            }
            
            /* Ensure keyboard content fits within viewport */
            prefab-virtual-keyboard::part(keyboard-container) {
                max-width: 100vw !important;
                transform-origin: top left !important;
            }
            
            /* Log section adjustments */
            .log-section {
                margin: 20px auto;
            }
            
            .event-log {
                max-height: 200px;
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div class="demo-container">
        <h1>Virtual Keyboard</h1>
        <div class="description">
            This is a pure layout demonstration of the virtual keyboard using prefab-virtual-keyboard element.<br>
        </div>
        
        <!-- Text input area -->
        <div class="input-section">
            <label for="text-input">Text Input Area:</label>
            <textarea id="text-input" placeholder="Enter text here, or click virtual keyboard buttons..." rows="4"></textarea>
            <div style="margin-top: 10px; font-size: 12px; color: #666;">
                💡 Tip: Click the input field or use mouse to select text area to activate keyboard input
            </div>
        </div>
        
        <!-- Virtual keyboard container -->
        <div class="keyboard-container">
            <!-- Use prefab-virtual-keyboard element to display virtual keyboard -->
            <prefab-virtual-keyboard 
            id="demo-keyboard"
            keyboard-css-src="/qwerty-104-key-keyboard.css" 
            keyboard-html-src="/qwerty-104-key-keyboard.html"
            >
        </prefab-virtual-keyboard>
        </div>
        
        <!-- Event log area -->
        <div class="log-section">
            <div class="log-header">
                <h3>Keyboard Event Log (Max 100 entries)</h3>
                <button id="clear-log">Clear Log</button>
            </div>
            <div id="event-log" class="event-log"></div>
        </div>
    </div>
    
    <script type="module">
        // Import prefab-virtual-keyboard custom element
        import './prefab-virtual-keyboard.js';

        // Hardcoded natural dimensions for the QWERTY 104-key keyboard
        const KEYBOARD_NATURAL_WIDTH = 1044; // pixels
        const KEYBOARD_NATURAL_HEIGHT = 360; // pixels

        // Mobile portrait detection function
        function isMobilePortrait() {
            // Check if it's a mobile device in portrait orientation OR small screen
            const userAgent = navigator.userAgent.toLowerCase();
            const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
            const isPortrait = window.innerHeight > window.innerWidth;
            const isSmallScreen = window.innerWidth <= 768; // Consider small screens as mobile-like
            
            console.log('Demo: Mobile portrait detection', {
                userAgent: navigator.userAgent,
                isMobile,
                isPortrait,
                isSmallScreen,
                windowWidth: window.innerWidth,
                windowHeight: window.innerHeight,
                result: (isMobile && isPortrait) || isSmallScreen
            });
            
            return (isMobile && isPortrait) || isSmallScreen;
        }

        // Override the scaling behavior for demo page
        function setupDemoKeyboardScaling() {
            const keyboard = document.getElementById('demo-keyboard');
            if (!keyboard) return;

            // Store original applyScaling method
            const originalApplyScaling = keyboard.applyScaling;

            // Override applyScaling with demo-specific logic
        keyboard.applyScaling = function() {
            // ARCHITECTURAL PRINCIPLE: prefab-virtual-keyboard should be agnostic
            // It should scale the container without touching the internal virtual-keyboard element
            
            // For mobile portrait mode, ignore all scaling restrictions and use zoom scaling
            if (isMobilePortrait()) {
                // Demo: Mobile portrait mode detected - using zoom scaling (agnostic scaling)
                
                // ARCHITECTURAL PRINCIPLE: For mobile, we need to balance architecture with usability
                // On small screens, we scale the entire keyboard to fit width while maintaining aspect ratio
                const container = this.getContainer();
                if (container) {
                    const keyboardElement = container.querySelector('virtual-keyboard');
                    if (keyboardElement) {
                        // Calculate scale factor to fit width
                        const scaleFactor = window.innerWidth / KEYBOARD_NATURAL_WIDTH;
                        
                        // Apply zoom scaling to container (not the internal element directly)
                        this.style.zoom = scaleFactor;
                        this.style.width = '100%';
                        this.style.maxWidth = '100%';
                        this.style.margin = '0';
                        this.style.padding = '0';
                        
                        // Clear transform styles to avoid conflicts
                        this.style.transform = '';
                        this.style.transformOrigin = '';
                        
                        // Demo: Mobile zoom scaling applied
                        
                        return;
                    }
                }
                
                // Fallback: Force 100% width for mobile portrait
                this.style.width = '100vw';
                this.style.maxWidth = '100vw';
                this.style.margin = '0';
                this.style.padding = '0';
                this.style.zoom = '';
                this.style.transform = '';
                this.style.transformOrigin = '';
                
                // Demo: Fallback mobile width applied
                return;
            }

            // For desktop or landscape mode, use the original logic but with natural size comparison
            const container = this.getContainer();
            if (!container || !this.isContentLoaded || this.naturalWidth === 0 || this.naturalHeight === 0) return;

            const keyboardElement = container.querySelector('virtual-keyboard');
            if (!keyboardElement) return;

            // ARCHITECTURAL PRINCIPLE: Reset only container styles, never touch internal virtual-keyboard
            this.style.width = '';
            this.style.maxWidth = '';
            this.style.margin = '';
            this.style.padding = '';
            this.style.transform = '';
            this.style.transformOrigin = '';
            this.style.zoom = '';

            // Check if window is larger than natural keyboard size
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Demo: Window size check (agnostic scaling)

            // If window is larger than natural size, don't stretch - maintain natural size
            if (windowWidth > KEYBOARD_NATURAL_WIDTH) {
                // Demo: Window larger than natural size - maintaining natural dimensions (agnostic)
                
                // Set the prefab element to natural size (centered by CSS)
                this.style.width = KEYBOARD_NATURAL_WIDTH + 'px';
                this.style.maxWidth = KEYBOARD_NATURAL_WIDTH + 'px';
                this.style.margin = '0 auto';
                
                // DO NOT touch the internal virtual-keyboard element
                // Demo: Internal virtual-keyboard element left untouched (natural size maintained)
                return;
            }

            // If window is smaller than natural size, use original scaling logic
            // ARCHITECTURAL PRINCIPLE: Let the original scaling handle container scaling
            // The original method now uses transform on the container, not the internal element
            // Demo: Window smaller than natural size - using agnostic original scaling
            
            // Clear any forced dimensions before calling original scaling
            this.style.width = '';
            this.style.maxWidth = '';
            this.style.margin = '';
            
            originalApplyScaling.call(this);
        };

            // Initial scaling
            keyboard.applyScaling();

            // Listen for orientation changes on mobile
            window.addEventListener('orientationchange', () => {
                setTimeout(() => {
                    keyboard.applyScaling();
                }, 100); // Small delay to let dimensions settle
            });

            // Listen for window resize
            window.addEventListener('resize', () => {
                keyboard.applyScaling();
            });

            // Demo: Custom scaling logic initialized
            // Demo: Natural keyboard dimensions
        }

        // Keyboard event logging system
        class KeyboardEventLogger {
            constructor() {
                this.logContainer = document.getElementById('event-log');
                this.clearButton = document.getElementById('clear-log');
                this.maxLogEntries = 100;
                this.logEntries = [];
                
                this.initializeEventListeners();
                this.bindClearButton();
            }

            initializeEventListeners() {
                // Listen to all keyboard events uniformly
                window.addEventListener('keydown', (event) => {
                    const source = this.isVirtualKeyboardEvent(event) ? 'virtual' : 'physical';
                    this.logEvent('keydown', source, event);
                });

                window.addEventListener('keyup', (event) => {
                    const source = this.isVirtualKeyboardEvent(event) ? 'virtual' : 'physical';
                    this.logEvent('keyup', source, event);
                });

                // Listen to text input area changes
                const textInput = document.getElementById('text-input');
                if (textInput) {
                    textInput.addEventListener('input', (event) => {
                        this.logInputEvent(event);
                    });
                }
            }

            isVirtualKeyboardEvent(event) {
                // Check virtual keyboard marker on event object first
                if (event.isVirtualKeyboard) {
                    return true;
                }
                
                // Fallback to path checking (compatibility)
                const path = event.composedPath();
                for (let el of path) {
                    if (el && el.tagName) {
                        const tag = el.tagName.toLowerCase();
                        if (tag === 'virtual-key' || tag === 'virtual-keyboard' || tag === 'prefab-virtual-keyboard') {
                            return true;
                        }
                    }
                }
                return false;
            }

            logEvent(type, source, event) {
                const timestamp = new Date().toLocaleTimeString();
                
                let keyInfo = '';
                let codeInfo = '';

                if (source === 'virtual' || source === 'physical') {
                    // Handle all keyboard events uniformly, whether virtual or physical
                    keyInfo = event.key || 'Unknown';
                    codeInfo = event.code || 'unknown';
                }

                // Check virtual keyboard marker
                const isVirtualKeyboard = event.isVirtualKeyboard || false;
                const actualSource = isVirtualKeyboard ? 'virtual' : source;

                // Get standard KeyboardEvent modifier key states
                const modifiers = {
                    ctrl: event.ctrlKey || false,
                    alt: event.altKey || false,
                    shift: event.shiftKey || false,
                    meta: event.metaKey || false,
                    repeat: event.repeat || false,
                    isComposing: event.isComposing || false,
                    location: event.location || 0
                };

                const logEntry = {
                    timestamp,
                    type,
                    source: actualSource,
                    key: keyInfo,
                    code: codeInfo,
                    isVirtualKeyboard: isVirtualKeyboard, // Add marker information
                    modifiers: modifiers, // Add modifier key states
                    fullEvent: event // Complete native event object
                };

                this.addLogEntry(logEntry);
            }

            logInputEvent(event) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = {
                    timestamp,
                    type: 'input',
                    source: 'text',
                    key: event.data || 'Backspace/Del',
                    code: 'input',
                    fullEvent: event
                };

                this.addLogEntry(logEntry);
            }

            addLogEntry(logEntry) {
                this.logEntries.push(logEntry); // Add to end
                
                // Limit log entries
                if (this.logEntries.length > this.maxLogEntries) {
                    this.logEntries = this.logEntries.slice(-this.maxLogEntries);
                }

                this.renderLog();
            }

            renderLog() {
                // Plain text log format
                const logText = this.logEntries.map(entry => {
                    const typeMarker = entry.type === 'keydown' ? '▼' : '▲';
                    const sourceMarker = entry.source === 'physical' ? '🔧' : 
                                        entry.source === 'virtual' ? '⌨️' : '📝';
                    const virtualMarker = entry.isVirtualKeyboard ? ' (virtual)' : '';
                    
                    // Format modifier keys display
                    let modifierStr = '';
                    if (entry.modifiers) {
                        const activeModifiers = [];
                        if (entry.modifiers.ctrl) activeModifiers.push('Ctrl');
                        if (entry.modifiers.alt) activeModifiers.push('Alt');
                        if (entry.modifiers.shift) activeModifiers.push('Shift');
                        if (entry.modifiers.meta) activeModifiers.push('Meta');
                        
                        if (activeModifiers.length > 0) {
                            modifierStr = ` [${activeModifiers.join('+')}]`;
                        }
                        
                        // Add additional property information using modern JS features
                        modifierStr += entry.modifiers.repeat ? ' (repeat)' : '';
                        modifierStr += entry.modifiers.isComposing ? ' (composing)' : '';
                        
                        const locationNames = ['', 'Left', 'Right', 'Numpad'];
                        const location = entry.modifiers.location ?? 0;
                        if (location !== 0) {
                            modifierStr += ` (${locationNames[location] ?? 'Unknown'})`;
                        }
                    }
                    
                    return `${entry.timestamp} ${typeMarker}${sourceMarker} ${entry.type} ${entry.source} ${entry.key} [${entry.code}]${virtualMarker}${modifierStr}`;
                }).join('\n');
                
                this.logContainer.textContent = logText;
                
                // Auto-scroll to bottom (latest logs)
                this.logContainer.scrollTop = this.logContainer.scrollHeight;
            }

            bindClearButton() {
                this.clearButton.addEventListener('click', () => {
                    this.clearLog();
                });
            }

            clearLog() {
                this.logEntries = [];
                this.renderLog();
                
                // Add clear notification (system log entry)
                const logEntry = {
                    timestamp: new Date().toLocaleTimeString(),
                    type: 'system',
                    source: 'log',
                    key: 'Log cleared',
                    code: 'clear'
                };
                
                this.logEntries.push(logEntry);
                this.renderLog();
            }
        }

        // Input activation manager
        class InputActivationManager {
            constructor() {
                this.textInput = document.getElementById('text-input');
                this.activeClass = 'input-active';
                this.initializeActivation();
            }

            initializeActivation() {
                // Set up focus event listeners for the input field
                this.textInput.addEventListener('focus', () => {
                    this.activateInput(this.textInput);
                });

                this.textInput.addEventListener('blur', () => {
                    this.deactivateInput(this.textInput);
                });

                // Initial state check (focus check on load)
                if (document.activeElement === this.textInput) {
                    this.activateInput(this.textInput);
                }
            }

            activateInput(inputElement) {
                inputElement.classList.add(this.activeClass);
                console.log('Input field activated:', inputElement.id);
            }

            deactivateInput(inputElement) {
                inputElement.classList.remove(this.activeClass);
                console.log('Input field deactivated:', inputElement.id);
            }
        }





        // Initialize keyboard event log system
        document.addEventListener('DOMContentLoaded', () => {
            const logger = new KeyboardEventLogger();
            const inputManager = new InputActivationManager();
            console.log('Keyboard event log system started');
            console.log('Input activation manager started');
            
            // Setup custom demo keyboard scaling after keyboard is loaded
            const keyboard = document.getElementById('demo-keyboard');
            if (keyboard) {
                // Wait for keyboard content to load
                if (keyboard.isContentLoaded) {
                    setupDemoKeyboardScaling();
                } else {
                    keyboard.addEventListener('content-loaded', () => {
                        setupDemoKeyboardScaling();
                    });
                }
            }
            
            // Add welcome log
            setTimeout(() => {
                logger.addLogEntry({
                    timestamp: new Date().toLocaleTimeString(),
                    type: 'system',
                    source: 'log',
                    key: 'Keyboard event listener started',
                    code: 'ready'
                });
            }, 100);
        });
        
        // Remove test controls - no longer needed
        function addTestControls() {
            // Test controls removed for production
            console.log('Test controls removed');
        }

        // Debug function to test mobile portrait detection (can be called from console)
        window.testMobilePortraitDetection = function() {
            const userAgent = navigator.userAgent.toLowerCase();
            const isMobile = /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent);
            const isPortrait = window.innerHeight > window.innerWidth;
            
            console.log('=== Mobile Portrait Detection Test ===');
            console.log('User Agent:', navigator.userAgent);
            console.log('Is Mobile (regex test):', isMobile);
            console.log('Is Portrait (height > width):', isPortrait);
            console.log('Window Width:', window.innerWidth);
            console.log('Window Height:', window.innerHeight);
            console.log('Final Result (isMobile && isPortrait):', isMobile && isPortrait);
            console.log('=====================================');
            
            return {
                userAgent: navigator.userAgent,
                isMobile,
                isPortrait,
                windowWidth: window.innerWidth,
                windowHeight: window.innerHeight,
                result: isMobile && isPortrait
            };
        };

        // Test scaling behavior
        window.testScalingBehavior = function() {
            console.log('=== Keyboard Scaling Debug ===');
            
            // Get current window dimensions
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            console.log('Window size:', windowWidth + 'x' + windowHeight);
            
            // Check natural size
            const keyboard = document.querySelector('prefab-virtual-keyboard');
            if (keyboard) {
                console.log('Natural size:', keyboard.naturalWidth + 'x' + keyboard.naturalHeight);
                console.log('Is mobile portrait:', isMobilePortrait());
                
                // Check current styles
                const container = keyboard.getContainer?.();
                const keyboardElement = container?.querySelector('virtual-keyboard');
                
                if (keyboardElement) {
                    console.log('Keyboard element styles:');
                    console.log('- width:', keyboardElement.style.width);
                    console.log('- maxWidth:', keyboardElement.style.maxWidth);
                    console.log('- margin:', keyboardElement.style.margin);
                    console.log('- transform:', keyboardElement.style.transform);
                    console.log('- zoom:', keyboardElement.style.zoom);
                }
                
                // Check computed styles
                const computedStyles = window.getComputedStyle(keyboard);
                console.log('Computed styles:');
                console.log('- width:', computedStyles.width);
                console.log('- margin-left:', computedStyles.marginLeft);
                console.log('- padding-left:', computedStyles.paddingLeft);
                console.log('- left:', computedStyles.left);
                console.log('- position:', computedStyles.position);
            }
            
            // Force a scaling update
            console.log('Forcing scaling update...');
            keyboard?.applyScaling?.();
            
            console.log('=== End Debug ===');
        };

        // Debug left margin specifically
        window.debugLeftMargin = function() {
            console.log('=== Left Margin Debug ===');
            
            const keyboard = document.querySelector('prefab-virtual-keyboard');
            if (keyboard) {
                const container = keyboard.getContainer?.();
                const keyboardElement = container?.querySelector('virtual-keyboard');
                
                console.log('Keyboard container:');
                if (container) {
                    const containerStyles = window.getComputedStyle(container);
                    console.log('- margin-left:', containerStyles.marginLeft);
                    console.log('- padding-left:', containerStyles.paddingLeft);
                    console.log('- left:', containerStyles.left);
                    console.log('- position:', containerStyles.position);
                    console.log('- transform:', containerStyles.transform);
                }
                
                console.log('Keyboard element:');
                if (keyboardElement) {
                    const elementStyles = window.getComputedStyle(keyboardElement);
                    console.log('- margin-left:', elementStyles.marginLeft);
                    console.log('- padding-left:', elementStyles.paddingLeft);
                    console.log('- left:', elementStyles.left);
                    console.log('- position:', elementStyles.position);
                    console.log('- transform:', elementStyles.transform);
                }
                
                console.log('Keyboard component itself:');
                const keyboardStyles = window.getComputedStyle(keyboard);
                console.log('- margin-left:', keyboardStyles.marginLeft);
                console.log('- padding-left:', keyboardStyles.paddingLeft);
                console.log('- left:', keyboardStyles.left);
                console.log('- position:', keyboardStyles.position);
                console.log('- transform:', keyboardStyles.transform);
            }
            
            // Check parent elements
            console.log('Parent chain:');
            let element = keyboard;
            while (element && element !== document.body) {
                const styles = window.getComputedStyle(element);
                console.log(`${element.tagName || element.className}: margin-left=${styles.marginLeft}, padding-left=${styles.paddingLeft}, left=${styles.left}`);
                element = element.parentElement;
            }
            
            console.log('=== End Left Margin Debug ===');
        };

        // Debug architectural principle: virtual-keyboard should maintain natural size
        window.debugArchitecturalPrinciple = function() {
            console.log('=== Architectural Principle Debug ===');
            console.log('Principle: prefab-virtual-keyboard should be agnostic');
            console.log('Principle: Only scale the container, never modify internal virtual-keyboard');
            
            const keyboard = document.querySelector('prefab-virtual-keyboard');
            if (keyboard) {
                const container = keyboard.getContainer?.();
                const keyboardElement = container?.querySelector('virtual-keyboard');
                
                console.log('Natural dimensions (should be 1044x360):');
                console.log('- Natural width:', keyboard.naturalWidth);
                console.log('- Natural height:', keyboard.naturalHeight);
                
                if (keyboardElement) {
                    console.log('Internal virtual-keyboard element (SHOULD maintain natural size):');
                    const elementStyles = window.getComputedStyle(keyboardElement);
                    console.log('- width:', elementStyles.width);
                    console.log('- height:', elementStyles.height);
                    console.log('- max-width:', elementStyles.maxWidth);
                    console.log('- max-height:', elementStyles.maxHeight);
                    console.log('- transform:', elementStyles.transform);
                    console.log('- zoom:', elementStyles.zoom);
                    
                    // Check if element maintains natural size
                    const maintainsNaturalSize = 
                        elementStyles.width === '1044px' && 
                        elementStyles.height === '360px' &&
                        elementStyles.transform === 'none' &&
                        elementStyles.zoom === '1';
                    
                    console.log('✅ Maintains natural size:', maintainsNaturalSize);
                    if (!maintainsNaturalSize) {
                        console.log('❌ VIOLATION: Internal virtual-keyboard element has been modified!');
                    }
                }
                
                console.log('Prefab container (CAN be modified for scaling):');
                const keyboardStyles = window.getComputedStyle(keyboard);
                console.log('- width:', keyboardStyles.width);
                console.log('- height:', keyboardStyles.height);
                console.log('- transform:', keyboardStyles.transform);
                console.log('- zoom:', keyboardStyles.zoom);
            }
            
            console.log('=== End Architectural Principle Debug ===');
        };

        // Test scaling behavior - verify keyboard can scale down AND back up
        window.testScalingBehavior = function() {
            console.log('=== Testing Scaling Behavior ===');
            
            const keyboard = document.querySelector('prefab-virtual-keyboard');
            if (!keyboard) {
                console.log('No keyboard found');
                return;
            }
            
            console.log('Current state:');
            debugArchitecturalPrinciple();
            
            console.log('Testing scale down...');
            // Simulate small window
            const originalWidth = window.innerWidth;
            Object.defineProperty(window, 'innerWidth', {
                writable: true,
                configurable: true,
                value: 800
            });
            window.dispatchEvent(new Event('resize'));
            
            setTimeout(() => {
                console.log('After scale down:');
                debugArchitecturalPrinciple();
                
                console.log('Testing scale back up...');
                // Restore large window
                Object.defineProperty(window, 'innerWidth', {
                    writable: true,
                    configurable: true,
                    value: originalWidth
                });
                window.dispatchEvent(new Event('resize'));
                
                setTimeout(() => {
                    console.log('After scale back up:');
                    debugArchitecturalPrinciple();
                    console.log('=== End Scaling Test ===');
                }, 500);
            }, 500);
        };

        // Test mobile scaling behavior
        window.testMobileScaling = function() {
            const widths = [375, 414, 768, 1024, 1200];
            let currentIndex = 0;
            
            function testNextWidth() {
                if (currentIndex >= widths.length) {
                    console.log('Mobile scaling test completed');
                    return;
                }
                
                const width = widths[currentIndex];
                console.log(`Testing width: ${width}px`);
                
                // Simulate window resize
                Object.defineProperty(window, 'innerWidth', {
                    writable: true,
                    configurable: true,
                    value: width
                });
                
                // Trigger resize event
                window.dispatchEvent(new Event('resize'));
                
                // Check if mobile portrait is detected
                const isMobile = isMobilePortrait();
                console.log(`Width ${width}px - isMobilePortrait: ${isMobile}`);
                
                // Check applied styles
                const keyboard = document.getElementById('demo-keyboard');
                if (keyboard) {
                    const keyboardStyle = window.getComputedStyle(keyboard);
                    console.log(`Width ${width}px - prefab-keyboard styles:`, {
                        width: keyboardStyle.width,
                        maxWidth: keyboardStyle.maxWidth,
                        transform: keyboardStyle.transform,
                        transformOrigin: keyboardStyle.transformOrigin
                    });
                    
                    const container = keyboard.getContainer();
                    if (container) {
                        const virtualKeyboard = container.querySelector('virtual-keyboard');
                        if (virtualKeyboard) {
                            const computedStyle = window.getComputedStyle(virtualKeyboard);
                            console.log(`Width ${width}px - virtual-keyboard styles:`, {
                                width: computedStyle.width,
                                maxWidth: computedStyle.maxWidth,
                                transform: computedStyle.transform,
                                transformOrigin: computedStyle.transformOrigin
                            });
                        }
                        
                        const containerStyle = window.getComputedStyle(container);
                        console.log(`Width ${width}px - container styles:`, {
                            width: containerStyle.width,
                            maxWidth: containerStyle.maxWidth,
                            transform: containerStyle.transform,
                            transformOrigin: containerStyle.transformOrigin
                        });
                    }
                }
                
                currentIndex++;
                setTimeout(testNextWidth, 1000);
            }
            
            testNextWidth();
        };
        
        // Debug function to check current mobile state
        window.debugMobileState = function() {
            console.log('Mobile Debug State:');
            console.log('- Mobile portrait mode:', isMobilePortrait());
            console.log('- Window size:', window.innerWidth + 'x' + window.innerHeight);
            
            // Check keyboard element
            const keyboard = document.getElementById('demo-keyboard');
            if (keyboard) {
                // Check inline styles
                console.log('- Keyboard styles:', {
                    zoom: keyboard.style.zoom || 'none',
                    transform: keyboard.style.transform || 'none'
                });
            } else {
                console.log('- Keyboard element not found');
            }
        };
    </script>
</body>
</html>